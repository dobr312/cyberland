# CyberGenesis Land Mint DApp

## Overview
A cyberpunk-themed land minting DApp where users can generate and claim multiple virtual land plots with deterministic coordinates and biomes based on their Internet Identity principal. Users can claim ICRC-1 token rewards over time, upgrade their plots using accumulated tokens, customize their land with names and decorations, compete on a global leaderboard, trade land NFTs and modifiers in a P2P marketplace, participate in decentralized governance, and engage in long-term discovery mechanics through a three-tiered loot cache system with energy-based balance mechanisms. The system supports multi-land ownership through scarce LandToken consumption for additional plot minting.

## Authentication
- Internet Identity integration for user login using `@dfinity/auth-client`
- Enhanced authentication flow with proper session handling:
  - Check for existing authenticated session on app initialization
  - If user is already authenticated, automatically set identity and skip login process
  - Silently reuse current session and immediately update frontend state to "authenticated"
  - Proper async login handling with `await authClient.login({ onSuccess: ... })` only when not already authenticated
- **Enhanced session validation and restoration**:
  - Validate restored sessions before actor creation to ensure they are not expired or invalid
  - Clear stored sessions and trigger fresh login flow when expired or invalid identity is detected
  - Consistent error handling and console logging for easier diagnosis of identity authentication issues
- Visual loading feedback (glow animation) while Internet Identity window is open
- Store authenticated principal and switch to dashboard state after successful login
- **Ultra-robust actor initialization with maximum fault tolerance configuration and comprehensive retry logic**:
  - **Actor creation timeout extended to 120 seconds** for maximum stability under all network conditions
  - **Progressive backoff retry loops with exponential delays** for up to 120 seconds before showing fatal error
  - **Up to 25 automatic retry attempts** with progressive delays (1s, 2s, 4s, 8s, 16s, 32s, 64s) before reporting failure
  - **Comprehensive connection handling** to prevent disconnection during initialization
  - **Enhanced initialization data poller** that continuously attempts to fetch Network Status and Admin status data with progressive backoff retries for up to 120 seconds with 25 retry attempts until stable connection is confirmed or timeout threshold is reached
  - **Smooth startup under poor network conditions** with persistent retry mechanisms and consistent user feedback
  - **Fatal error display only after 120-second timeout** with clear retry instructions
  - **Primary gateway configuration**: All backend actor connections use `https://ic0.app` as the default primary gateway with automatic failover to `https://boundary.ic0.app` and `https://icp-api.io`
  - **Async error handling**: Robust asynchronous error trapping and retry scheduling to handle early "Network fetch failed" exceptions gracefully without bypassing retry logic
  - **Complete actor reinitialization system**: Rebuild all actor connections from scratch to restore canister visibility and fix offline status issues
  - **Enhanced connection diagnostics**: Real-time monitoring and reporting of connection status for all canisters with visual indicators
  - **Network reinitialization protocol**: Full network connection refresh and gateway synchronization to restore Connected status
- Display user's Principal ID after connection
- Login button behavior:
  - When not authenticated: initiate login process
  - When already authenticated: show notification "You are already logged in via Internet Identity"
- Logout functionality that fully clears identity data and local state before allowing new login

## Plug Wallet Integration
- Plug Wallet integration as primary Web3 wallet for authentication and transaction signing
- "Connect Wallet" button in dashboard header that initiates Plug connection
- Plug wallet authorization requests for both LandCanister and CyberTokenCanister Principal IDs
- React context to store connected Plug Principal and wallet state accessible across components
- All transaction-triggering actions use authenticated Plug wallet for signing:
  - `discoverLootCache` function calls
  - `buyLand` marketplace transactions
  - `stakeTokens` governance operations
  - CBR and ICP payment button actions
  - `useConsumableBuff` function calls
  - `mintLand` function calls for additional land creation
  - `list_item` and `buy_item` marketplace transactions
- Secure inter-canister call execution via Plug's API for all wallet-signed transactions
- Display connected Plug Principal ID in the UI
- "Disconnect Wallet" option to clear Plug wallet connection and state
- Plug wallet state persistence across page reloads and browser sessions

## Post-Authentication Initialization
- After successful Internet Identity login, automatically call backend's `initializeAccessControl()` method
- **Ultra-reinforced initialization flow with maximum fault tolerance configuration, comprehensive retry logic, enhanced error handling, and fail-safe mechanisms:**
  - **Ultra-robust retry loops for all backend canisters** (AssetCanister, LandCanister, CyberTokenCanister, MarketplaceCanister, GovernanceCanister) with up to 120 seconds of retry attempts using progressive backoff with 25 retry attempts
  - **Enhanced initialization data poller** that continuously checks and attempts to fetch Network Status and Admin status data with progressive backoff retries for up to 120 seconds with 25 retry attempts until stable connection is confirmed or timeout threshold is reached
  - **Cyclic polling mechanism for continuous network status verification**: Implement continuous polling that checks network connectivity and canister status every 5 seconds with progressive backoff during initialization phase until stable connection or 120-second timeout
  - **High-tolerance connection logic**: Retry until success or 120-second timeout for all actor hooks (`useActor`, `useAssetActor`, `useCyberTokenActor`, `useMarketplaceActor`, `useGovernanceActor`)
  - **Automatic retry mechanism with progressive exponential backoff**: `initializeAccessControl()` retries continuously with progressive delays (1s, 2s, 4s, 8s, 16s, 32s, 64s) for up to 120 seconds on failure
  - **Up to 25 reconnection attempts** for each canister with exponential backoff before declaring failure
  - **Primary gateway configuration**: All backend actor connections use `https://ic0.app` as the default primary gateway with automatic failover to backup boundary nodes
  - **Async error handling**: Robust asynchronous error trapping and retry scheduling to handle early "Network fetch failed" exceptions gracefully without bypassing retry logic
  - **Proper async/await patterns**: All async functions use `await` properly and are enclosed in comprehensive `try...catch` blocks
  - **Enhanced error messaging**: When failing after 120-second timeout, display user-readable error messages with specific context like "Canister temporarily unavailable, please try again" instead of generic "Initialization error" screen
  - **Sequential execution control**: Prevent LandCanister data queries (`getLandData`, `getCallerUserProfile`) until `initializeAccessControl()` returns successfully
  - **Dynamic loading states**: Display "Synchronizing access control..." during initialization state with clear progress indication and timeout countdown
  - **Automatic progression**: Proceed to dashboard automatically once actor and access control initialization are confirmed
  - **Ultra-robust actor creation with comprehensive retry logic**: Backend canister actors (LandCanister, CyberTokenCanister, AssetCanister, MarketplaceCanister, GovernanceCanister) are created with automatic retry mechanisms for up to 120 seconds when initialization fails
  - **Environment variable validation**: Verify correct environment variables (`VITE_LAND_CANISTER_ID`, `VITE_CYBER_TOKEN_CANISTER_ID`, `VITE_ASSET_CANISTER_ID`, `VITE_MARKETPLACE_CANISTER_ID`, `VITE_GOVERNANCE_CANISTER_ID`) are used when creating actors
  - **HttpAgent initialization synchronization**: Ensure HttpAgent waits for Internet Identity or Plug Wallet authentication before creating backend actors
  - **Connection failure handling**: Display "Failed to create backend actor" errors with specific retry instructions and fallback mechanisms only after 120-second timeout
  - **Complete backend reconnection process**: Reinitialize all five backend canisters (LandCanister, GovernanceCanister, CyberTokenCanister, AssetCanister, MarketplaceCanister) connections from the frontend with full redeployment validation
  - **Canister availability verification**: Test each canister connection individually before proceeding with initialization
  - **Fallback actor creation**: Implement secondary actor creation paths when primary initialization fails
  - **Connection state monitoring**: Continuously monitor backend connection health and automatically reconnect when needed
  - **Smooth startup under poor network conditions**: Persistent retry mechanisms ensure initialization completes even with network instability
  - **Progressive backoff for network polling**: Use progressive backoff (1s, 2s, 4s, 8s, 16s, 32s, 64s) for network status checks to prevent overwhelming the network during poor connectivity
  - **Connection stability monitoring**: Monitor connection health continuously and trigger automatic reconnection when instability is detected
  - **Complete actor reinitialization system**: Rebuild all actor connections from scratch to restore canister visibility and fix offline status issues
  - **Network reinitialization protocol**: Full network connection refresh and gateway synchronization to restore Connected status
  - **Enhanced connection diagnostics**: Real-time monitoring and reporting of connection status for all canisters with visual indicators
  - **Canister health verification**: Perform comprehensive health checks for AssetCanister (bd3sg-teaaa-aaaaa-qaaba-cai) and LandCanister (br5f7-7uaaa-aaaaa-qaaca-cai)
  - **Gateway status restoration**: Restore Connected status for all gateways and canisters through complete reinitialization
  - `isInitializing` state to track initialization progress with timeout tracking
  - `isInitialized` state to confirm completion
  - Visual loading animation with text "Preparing profile and land data..." during initialization with progress feedback
  - All data-fetching calls (`getLandData`, `getCallerUserProfile`) execute only after `initializeAccessControl()` completes successfully
  - Proper state checks in `useActorWithInit` and dependent hooks like `useActor`
  - Dashboard rendering blocked until initialization is complete
  - Smooth transition from initialization to dashboard display without hang or stuck states
  - Error boundary implementation with explicit error handling for failed initialization
  - Display "Error loading profile or land data" message when initialization or data fetching fails after 120-second timeout
  - Console error output for debugging API exceptions and unresolved promises
- Ensure `getLandData()` and `getCallerUserProfile()` work reliably after initialization
- Safe handling for users without existing role or land data - automatically initialize both
- Prevent access errors during first-time user setup
- Clear loading indicator in `App.tsx` showing "Preparing profile and land data..." while initialization is in progress with timeout feedback
- **All asynchronous calls in React components use proper `await` keyword inside `async` functions wrapped in `try...catch` blocks**
- **Frontend notification system using Toaster for caught errors during initial data fetch with clear error messages like "Failed to load land data" or "Initialization timeout"**
- **React hooks `useActorWithInit`, `useActor`, and components like `Dashboard.tsx`, `LandDashboard.tsx`, and `ProfileSetup.tsx` properly handle initialization promises and catch backend errors before rendering dependent UI state**

## Complete Actor Reinitialization System
- **Execute complete rebuild of all frontend-backend actor connections** to restore canister visibility and fix offline status issues:
  - **Full actor system reinitialization**: Rebuild all actor hooks and connection logic from scratch
  - **Fresh HttpAgent initialization**: Create new HttpAgent instances with updated gateway configuration
  - **Reinitialize all canister actor instances**: Clean state initialization for all backend canisters
  - **Verify all actor methods**: Ensure proper binding and accessibility after reinitialization
  - **Network environment stabilization**: Establish clean connections within stable network environment
  - **Eliminate DISCONNECTED errors**: Proper connection sequencing to prevent offline status
  - **Connection stability verification**: Test connection reliability under various network conditions
- **Enhanced network reinitialization protocol**:
  - **Gateway synchronization**: Ensure all connections use `https://ic0.app` as primary gateway
  - **Connection health monitoring**: Real-time monitoring of all canister connections
  - **Automatic detection and recovery**: Identify and recover from connection issues
  - **Comprehensive logging**: Debug connection problems with detailed logging
  - **Visual connection indicators**: Show connection status for each canister in UI
  - **Restore Connected status**: Full network refresh to restore proper gateway and canister connectivity
- **Canister health verification system**:
  - **AssetCanister health checks**: Verify bd3sg-teaaa-aaaaa-qaaba-cai connectivity and status
  - **LandCanister health checks**: Verify br5f7-7uaaa-aaaaa-qaaca-cai connectivity and status
  - **Cycle balance monitoring**: Check canister resource availability
  - **Memory and compute validation**: Ensure canisters have sufficient resources
  - **Deployment consistency**: Verify WASM versions and configuration alignment
  - **Gateway connectivity tests**: Validate connection to ic0.app
  - **Automated recovery protocols**: Self-healing mechanisms for detected issues

## Network Configuration
- **Enhanced Internet Computer mainnet configuration with updated primary gateway and automatic failover**:
  - **`VITE_DFX_NETWORK` permanently set to `"ic"` for all builds (draft and live)**
  - **Updated gateway priority with `https://ic0.app` as primary gateway and automatic failover to multiple stable public IC boundary nodes**:
    - **Primary: `https://ic0.app`**
    - **Secondary: `https://boundary.ic0.app`**
    - **Tertiary: `https://icp-api.io`**
  - **Gateway health monitoring**: Continuous monitoring of boundary node connectivity and automatic switching to most stable endpoint
  - **HttpAgent initialization uses updated primary gateway `https://ic0.app` with 120-second timeout**
  - **Enhanced connection stability validation**: Test multiple boundary nodes and select the most responsive one during initialization
  - **Ensure initialization handshake uses live Internet Computer boundary node to prevent connection freezes**
  - **Async error handling**: Robust asynchronous error trapping and retry scheduling to handle early "Network fetch failed" exceptions gracefully without bypassing retry logic
  - **Complete network reinitialization**: Execute full network connection refresh to restore Connected status
  - **Environment configuration synchronization**: Align all network settings across frontend and backend
- **Asset Canister ID embedding with permanent configuration**:
  - **Permanently embed correct Asset Canister Principal ID `bd3sg-teaaa-aaaaa-qaaba-cai` in `VITE_ASSET_CANISTER_ID`**
  - **Embed Asset Canister ID in both draft and live environment configurations**
  - **Remove runtime environment variable dependencies by hardcoding Asset Canister ID in build process**
  - **Ensure Asset Canister ID matches deployed backend canister on public IC network**
  - **Validate and permanently attach correct `VITE_ASSET_CANISTER_ID` to prevent localhost connection attempts**
- **Corrected Land Canister ID configuration**:
  - **Permanently embed correct Land Canister Principal ID `br5f7-7uaaa-aaaaa-qaaca-cai` in `VITE_LAND_CANISTER_ID`**
  - **Verify all remaining canister IDs match mainnet deployment configuration**
  - **Synchronize all environment variables with deployed canister IDs on public IC network**
  - **Validate canister ID consistency across all frontend configuration files**
- **Enhanced network diagnostics and validation with connection stability monitoring**:
  - **Dynamic console logging confirming current network target is `ic`**
  - **Asset Canister connectivity status logging visible in browser console**
  - **Real-time network connection validation during app initialization**
  - **Connection health monitoring with automatic retry for failed connections**
  - **Network diagnostic information in Admin Panel for authorized users**
  - **Continuous connection stability monitoring with automatic reconnection triggers**
  - **Network status polling with progressive backoff to handle intermittent connectivity issues**
  - **Enhanced connection diagnostics**: Real-time reporting of canister connection status with visual indicators
  - **Gateway status monitoring**: Track and display connectivity status for all configured gateways
- **Build configuration stability**:
  - **Eliminate all runtime environment variable loading for network configuration**
  - **Hardcode all canister IDs and network settings directly in build process**
  - **Ensure production builds connect exclusively to public IC network**
  - **Verify all backend actor creation uses embedded public IC configuration**
- **Complete backend redeployment and connection refresh**:
  - **Execute complete backend redeployment routine to activate corrected public network configuration**
  - **Refresh all canister connections to use stable public IC endpoints**
  - **Verify full application UI and data loading post-initialization for complete stabilization**
  - **Full reinitialization**: Cleanly rebuild and redeploy both Asset Canister (bd3sg-teaaa-aaaaa-qaaba-cai) and Land Canister (br5f7-7uaaa-aaaaa-qaaca-cai) to ensure their Wasm modules, candid interfaces, and references are correctly initialized and compatible
- **Synchronized environment configuration**: Perfect alignment of canister IDs, host URLs, and gateway connections between frontend and backend to eliminate configuration mismatches

## Canister Health Diagnostics
- **Comprehensive canister health monitoring system** for LandCanister (br5f7-7uaaa-aaaaa-qaaca-cai) and AssetCanister (bd3sg-teaaa-aaaaa-qaaba-cai):
  - **Canister status verification**: Real-time checks to confirm both canisters are active and reachable on Internet Computer mainnet
  - **Cycle balance monitoring**: Automated queries to verify current T Cycles available and alert on resource starvation risks
  - **Memory and compute usage tracking**: Monitor storage limits and compute resource consumption to prevent capacity issues
  - **Deployment synchronization validation**: Verify WASM versions and inter-canister configuration consistency with deployment hash verification
  - **Gateway connectivity testing**: Automated network connectivity checks to `https://ic0.app`, `https://boundary.ic0.app`, and `https://icp-api.io` gateways with actor creation validation
  - **Response time measurement**: Track and report response times for each gateway to identify performance bottlenecks
  - **HTTP status code validation**: Verify proper HTTP responses (200 OK) from all gateway endpoints
  - **Automatic restoration protocols**: Self-healing mechanisms to restore or re-initialize affected canister configurations when issues are detected
  - **Connection status restoration**: Monitor and restore Connected status for all gateways and canisters
  - **Offline status resolution**: Detect and fix offline canister status through reinitialization protocols
  - **Gateway stability recommendations**: Provide recommendations for unstable nodes or gateways based on performance metrics
- **Enhanced diagnostic reporting system**:
  - **Real-time status dashboard**: Visual indicators showing canister health, cycle balances, and connectivity status
  - **Automated issue detection**: Proactive monitoring that identifies problems before they impact user experience
  - **Recovery automation**: Automatic execution of restoration procedures when canister issues are detected
  - **Detailed logging and alerts**: Comprehensive diagnostic information with specific error codes and resolution steps
  - **Connection status indicators**: Visual feedback showing Connected/Offline status for each canister and gateway
  - **Performance metrics display**: Show response times and success rates for each gateway endpoint
  - **Gateway health scoring**: Rate gateway stability and recommend optimal endpoints
- **Canister management functions**:
  - **Health check endpoints**: Backend functions to query canister status, memory usage, and cycle balances
  - **Configuration validation**: Verify inter-canister references and deployment consistency
  - **Emergency recovery procedures**: Automated protocols to restore normal operational state
  - **Performance monitoring**: Track response times and resource utilization patterns
  - **Connection restoration**: Automated procedures to restore canister visibility and connectivity
  - **Multi-gateway testing**: Test connectivity across all three gateway endpoints simultaneously
  - **Network stability assessment**: Evaluate overall network health and provide stability recommendations

## Frontend Features

### Enhanced Asset Health Monitoring System with Detailed Diagnostics
- **Direct Asset Canister health monitoring** without actor dependencies:
  - Performs health check using direct `fetch` to `https://bd3sg-teaaa-aaaaa-qaaba-cai.ic0.app/health`
  - Returns health status: `'CHECKING' | 'HEALTHY' | 'ERROR'`
  - Implements 2-second initial delay after component mount
  - Automatic status refresh every 30 seconds
  - No localStorage or sessionStorage caching for real-time status updates
  - Visual status indicators with color-coded borders and text
- **Enhanced diagnostic logging in AdminPanel checkHealth function**:
  - **Comprehensive response logging**: Log `response.ok`, `response.status`, `response.statusText` to console for detailed debugging
  - **Response text logging**: Log full `response.text()` content to understand exact health endpoint response
  - **Enhanced error condition handling**: Replace simple error status with detailed diagnostic information
  - **Improved status determination logic**: Check both `response.ok` and text content containing "HEALTHY" for accurate status assessment
  - **Comprehensive try-catch error handling**: Wrap all health check operations in try-catch with detailed error logging using `console.log("üí• Catch –±–ª–æ–∫:", error)` for clear exception visibility
  - **Detailed console output**: Provide complete diagnostic information to help administrators understand why error status is set even with 200 HTTP status

### Manual GLB Upload System
- **Direct GLB file upload functionality** without actor hooks:
  - Manual file selection and upload interface
  - Visual progress indicators during upload process
  - Success and error message display
  - File validation and size checking before upload attempts
  - Direct integration with Asset Canister upload endpoints
  - **No authentication requirements** - upload functionality works independently of wallet or identity connection status

### Simplified Floating Admin Panel Implementation
- **Updated AdminPanel component** (`frontend/src/components/AdminPanel.tsx`):
  - **Removes all authentication dependencies** - no Internet Identity or Plug wallet checks required
  - **Enhanced Asset Canister health monitoring** with detailed diagnostic logging and comprehensive error analysis
  - **Cache-busting parameters** added to health check requests to ensure real-time status updates
  - **Periodic health monitoring** with automatic refresh every 30 seconds
  - **Manual GLB upload functionality** with visual feedback and progress indicators
  - **No authorization checking** - upload operations work without any wallet or identity connection
  - **Real-time status display** with color-coded visual indicators:
    - "CHECKING‚Ä¶‚è≥" status with neutral styling during health checks
    - "HEALTHY ‚úÖ" status with green styling when canister is operational
    - "ERROR ‚ö†Ô∏è" status with red styling when canister is unavailable
  - **Floating positioning** using `fixed bottom-4 right-4 z-50` CSS classes
  - **Always visible floating panel** for all users without authentication restrictions
  - **Glassmorphism styling** with semi-transparent background and neon glow borders in dark theme
  - **Non-blocking initialization** that doesn't interfere with main app rendering
  - **Collapsible interface** with "–ó–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª–∏ (.glb)" toggle button
  - **Land type dropdown selector** with 7 static land types for GLB uploads
  - **Comprehensive file validation** with 50 MB size limit and GLB format checking
  - **Manual upload process** with progress tracking and status feedback
  - **Upload functionality requires only Asset Canister health status to be 'HEALTHY'** - no wallet dependency
  - **Canister ID display** showing `bd3sg-teaaa-aaaaa-qaaba-cai` at the bottom of the panel
  - **Enhanced diagnostic capabilities**: Detailed health check response analysis with comprehensive console logging for troubleshooting error status conditions

### Ethereal Cyberpunk UI Design
- **Unified "Soft Cyberpunk Space Noir" theme with controlled color palette**:
  - **Neon Green (#00ff41)** and **Cyber Blue (#00d4ff)** as primary accent colors
  - **Deep black (#000000)** and **dark grey (#1a1a1a)** background tones
  - **Glassmorphism effects**: Semi-transparent frosted panels with subtle neon glow borders and rounded corners
  - **High-contrast readability**: Enhanced font weights and color contrasts for perfect legibility
  - **Corrected global text color styling**: All default (non-themed) text changed from black to white or light-cyan while preserving existing accent colors (green, purple, magenta, etc.)
- **Low-resource animated cosmic background**: Nebula and stars with green/blue/purple hues covering the entire interface with subtle particle movement and depth
- **Performance optimization**: Minimal impact animations that don't interfere with R3F dynamic scenes
- **Visual harmony**: Seamless integration with existing 3D visualization components and dynamic biome backgrounds

### Compact Top-Right Header Bar
- **Always-visible minimalist header bar** positioned in the top-right corner consolidating key metrics and controls:
  - **Collection Mastery Display**: Shows `[Star Icon] 25/45` format with **accurate real-time count** of unique collected modifiers from `getMyModifications()` 
  - **Land Count Display**: Shows `[Land Icon] 3` format displaying total number of owned lands from user's land collection
  - **Connect Wallet Button**: Integrated for quick access to Plug Wallet connection
  - **Glassmorphism styling**: Semi-transparent frosted background with subtle glow borders
  - **Responsive design**: Adapts to different screen sizes while maintaining visibility

### Landing Page
- Hero section with animated 3D rotating cube using React Three Fiber
- "GET YOUR GENESIS PLOT" headline
- "Connect Internet Identity" button with proper AuthClient initialization
- Loading state with visual feedback during authentication process
- Soft Cyberpunk Space Noir theme with neon green and cyber blue accents
- Low-resource cosmic animated background with nebula and stars
- Smooth animations using Framer Motion
- Glassmorphism panels for content sections
- **Fixed UI layout**: Remove excessive blank space at the top and make the main menu and hero section visible immediately without scrolling

### Land Selector Component
- **Multi-land navigation interface** enabling users to switch between owned lands:
  - Dropdown selector showing all owned lands with plot names and coordinates
  - Directional arrow controls for sequential land browsing
  - Current land indicator with "Land X of Y" format
  - Visual preview thumbnails showing biome type for each land
- **Dynamic land data rendering** based on currently selected land:
  - All dashboard components update to reflect selected land's data
  - 3D visualization switches to selected land's biome and modifiers
  - Customization panels show selected land's name and decoration
  - Upgrade and claim buttons operate on currently selected land
- **Seamless land switching** with smooth transitions and state persistence
- **Glassmorphism styling** consistent with overall UI theme
- **Responsive design** for desktop and mobile interfaces

### My Land Dashboard
- Dashboard header with "Connect Wallet" button for Plug Wallet integration (now integrated in compact header bar)
- Connected Plug Principal ID display and "Disconnect Wallet" option
- **Enhanced CBR Balance Display with Comprehensive Error Handling, Audit Compliance, and Detailed Logging**: 
  - **Asynchronous call to `CyberTokenCanister`'s `icrc1_balance_of` method using connected Plug Wallet or Internet Identity principal with proper `await` keyword**
  - **Comprehensive `try...catch` blocks wrapping all balance fetch operations with specific error handling for network failures, canister errors, and timeout conditions**
  - **Raw `Nat` response conversion using `formatTokenBalance` utility from `tokenUtils.ts` that divides by `1e8` with proper decimal formatting using `toFixed(2)` to `toFixed(4)` precision and validation of numeric conversion**
  - **Detailed console logging for all balance operations: `console.log("Getting CBR balance for Principal:", principal)` and `console.log("CBR balance response:", response, "Formatted:", formattedBalance)`**
  - **Enhanced error logging with specific error codes and undefined actor responses: `console.error("CBR balance fetch error - Error code:", error.code, "Actor response:", actor)`**
  - **Fallback UI displaying "Balance unavailable" when fetch fails with detailed console logging of error messages and stack traces**
  - **Error toast notifications for failed balance fetches with specific error messages like "Failed to get CBR balance", "Network timeout", or "Canister unavailable"**
  - **Loading state indicator while balance is being fetched with timeout handling**
  - **Automatic retry mechanism for failed balance requests with progressive backoff**
  - **React Query invalidation triggers for immediate balance refresh after successful transactions**
  - **Clear error handling and toast logging when response is null, 0, or encounters network errors with readable status messages**
  - **Debug button or console function to manually refresh and log current on-chain CBR balance for validation**
  - **Reactive balance updates immediately after claiming daily rewards or completing token transactions**
  - Displayed in dedicated "CBR BALANCE" card with cyberpunk styling
- **Collection Mastery Progress**: Dynamic "Collection Mastery: [X]/45" metric using `getMyModifications()` from `LandCanister` to count unique modifier IDs and compute real-time progress out of 45 total available modifiers with cyberpunk visual styling in header bar only
- **Land Collection Display**: Shows total number of owned lands and current selection status
- **Land Information Card** displaying currently selected land information after login and initialization:
  - Coordinates (latitude and longitude)
  - Biome type (one of 7 valid biomes: `FOREST_VALLEY`, `ISLAND_ARCHIPELAGO`, `SNOW_PEAK`, `DESERT_DUNE`, `VOLCANIC_CRAG`, `MYTHIC_VOID`, `MYTHIC_AETHER`)
  - Current upgrade level (0-5) displayed as small unobtrusive text within the card
  - Last claim time
  - Plot name (customizable)
  - Decoration URL (if set)
  - Base token multiplier (displays +25% for MYTHIC_VOID and MYTHIC_AETHER lands)
- **Enhanced "CLAIM REWARDS" button with comprehensive error handling, audit compliance, and detailed logging** for currently selected land:
  - Shows remaining time until next claim (24-hour cooldown)
  - Disabled state when cooldown active
  - Applies base token multiplier for MYTHIC_VOID and MYTHIC_AETHER lands
  - Uses Plug wallet for transaction signing
  - **Detailed logging for claim operations: `console.log("Claiming rewards for land:", landId, "Principal:", principal)` and `console.log("Claim result:", result)`**
  - **Enhanced error handling with specific error messages for insufficient funds or transfer failures**
  - **Immediate balance refresh upon successful claim completion with React Query invalidation**
  - **Clear confirmation message display when tokens are successfully claimed with updated balance visible**
- "UPGRADE PLOT" button for spending tokens to increase upgrade level of currently selected land
  - Shows upgrade cost and current token balance
  - Disabled when insufficient tokens or max level reached
  - Uses Plug wallet for transaction signing
  - **Enhanced error handling with specific error messages and balance refresh**
- "CREATE NEW LAND" button for creating additional lands
  - Shows LandToken requirement and availability
  - Disabled when no LandTokens available
  - Uses Plug wallet for transaction signing
- "FIND" button that opens a new browser tab linking to currently selected land's coordinates on OpenStreetMap
- **Admin Debug Panel** (visible only to authorized users):
  - **"CHECK CANISTER BALANCE" button** that calls `getCanisterTokenBalance()` and displays the result
  - Shows canister's own CBR token balance for debugging and audit purposes
  - Console logging of canister balance results for developer verification
- Glassmorphism styling for all dashboard panels and cards

### Plot Customization Section
- "CUSTOMIZE PLOT" section in dashboard with:
  - Text input field for plot name (max 20 characters) with validation for currently selected land
  - Radio-style selection buttons with thumbnails for decoration models for currently selected land
  - "UPDATE NAME" button to call `updatePlotName()` using Plug wallet for currently selected land
  - "UPDATE DECORATION" button to call `updateDecoration()` using Plug wallet for currently selected land
- Real-time validation feedback for name length and URL format
- Visual confirmation when customizations are successfully saved
- Persistence of customizations after page reload
- Glassmorphism styling for customization panels

### Discovery Tab
- "DISCOVERY" tab with enhanced cyberpunk/glitch UI styling and glassmorphism panels
- Three-tiered loot cache system with distinct action buttons/cards:
  - **Common Cache (Tier 1)**: Shows "100 CBR / 200 Charge" cost with 0.05% LandToken drop chance
  - **Rare Cache (Tier 2)**: Shows higher CBR and Charge costs with 0.2% LandToken drop chance
  - **Legendary Cache (Tier 3)**: Shows premium CBR and Charge costs with 0.5% LandToken drop chance
- Payment method selector with toggle/radio buttons for "Pay CBR" and "Pay ICP" options
- **Enhanced "DISCOVER CACHE" buttons with comprehensive transaction handling, audit compliance, and detailed logging**:
  - **Proper async/await pattern for `discoverLootCache(tier)` function calls with explicit error handling**
  - **Comprehensive try-catch blocks with specific error handling for insufficient funds, transfer errors, and unauthorized access**
  - **Detailed logging for discovery operations: `console.log("Discovering cache tier:", tier, "Principal:", principal)` and `console.log("Discovery result:", result)`**
  - **Error toast notifications displaying readable error messages like "Insufficient CBR balance", "Transfer error", or "Unauthorized transaction" with backend error message propagation**
  - **Loading states during transaction processing with visual feedback and timeout handling**
  - **Immediate UI updates and balance refresh upon successful cache discovery with React Query invalidation**
  - **Frontend error capture and formatting of backend error messages for user-friendly display**
  - Shows CBR token cost or ICP cost based on selected payment method
  - Shows charge unit requirements for each tier
  - Disabled when insufficient resources
  - Uses Plug wallet for payment transaction signing
- Inventory section displaying all user's loot caches:
  - Cache ID, tier, and discovery timestamp
  - Unlock timer showing remaining time (4-hour delay)
  - "OPEN CACHE" button (enabled after delay or with charge cost)
  - Tier visualization for opened caches showing modification rarity
  - Uses Plug wallet for cache opening transactions
  - **Enhanced error handling for cache opening operations with user-facing error messages**
- Consumable items inventory section:
  - Display Energy Boosters with amount values
  - Display Consumable Buffs with type and duration information
  - Display LandTokens with current count and rarity indicator
  - "USE BUFF" buttons to call `useConsumableBuff(item_id)` using Plug wallet
  - Real-time updates when buffs are consumed
- Visual feedback for successful cache discovery and opening
- Real-time updates of cache status and inventory
- Dynamic UI updates after discovering caches or consuming buffs
- Glassmorphism styling for all discovery panels and cache cards

### Collection Tab
- "COLLECTION" tab with enhanced cyberpunk/glitch UI styling and glassmorphism panels
- Static modifier catalog display using `PLANNED_MODIFIER_CATALOG` array from JS/TS file
- Grid layout displaying 45+ modifier entries with:
  - Modifier name and ID
  - Rarity tier visual indicators (1-4)
  - Asset URL preview or placeholder
  - Visual rarity cues with Tailwind CSS:
    - Tier 1 (Common): neutral border
    - Tier 2 (Rare): blue glow effect
    - Tier 3 (Legendary): purple glow effect
    - Tier 4 (Mythic): gold/neon glow effect
- Framer Motion animations for hover effects and fade-in transitions
- Cyberpunk design consistency with glassmorphism styling
- Accessible from main navigation for visual verification
- Placeholder content before backend modifier data integration

### Leaderboard Tab
- "LEADERBOARD" tab with enhanced cyberpunk/glitch UI styling and glassmorphism panels
- Displays ranked list of top lands using `getTopLands()` data:
  - Rank number with neon styling
  - Plot name (customizable user names)
  - Upgrade level with visual indicators
  - CBR token balance with real-time updates and proper decimal formatting
  - Total land count for each user
- Sorting by upgrade level first, then by token balance for ties
- Configurable limit for number of entries displayed
- Auto-refresh functionality to keep rankings current

### Marketplace Tab
- "MARKETPLACE" tab with enhanced cyberpunk neon styling and glassmorphism panels
- Displays all active listings for both Land NFTs and Modifiers with:
  - Asset type indicator (Land or Modifier)
  - Land coordinates and biome information (using 7 valid biome names) for land listings
  - Modifier name and rarity tier for modifier listings
  - Plot name and upgrade level for land listings
  - Listing price in CBR tokens with proper decimal formatting
  - Seller principal information
  - **Enhanced "BUY ITEM" button with comprehensive transaction handling, audit compliance, and detailed logging**:
    - **Proper async/await pattern for `buy_item()` function calls with explicit error handling**
    - **Comprehensive try-catch blocks with specific error handling for insufficient funds, transfer errors, and item unavailability**
    - **Detailed logging for purchase operations: `console.log("Purchasing item:", itemId, "Principal:", principal)` and `console.log("Purchase result:", result)`**
    - **Error toast notifications with readable messages like "Insufficient CBR balance", "Item no longer available", or "Purchase failed" with backend error message capture and formatting**
    - **Loading states during purchase processing with visual feedback**
    - **Immediate balance and listing refresh upon successful purchase with React Query invalidation**
    - **Frontend error propagation system that captures backend error messages and displays user-facing notifications**
    - Uses Plug wallet for transaction signing
  - "CANCEL LISTING" button for user's own listings using Plug wallet
- Filtering controls for marketplace browsing:
  - Asset type filter (Land, Modifier, All)
  - Rarity tier filter for modifiers (Tier 1-4)
  - Price range filter with min/max CBR input fields
  - Real-time filtering updates without page reload
- List asset functionality:
  - "LIST MY LAND" button to create new land listings for currently selected land
  - "LIST MY MODIFIER" button to create new modifier listings from user's collection
  - Input field for setting sale price in CBR tokens
  - Calls `list_item()` on MarketplaceCanister using Plug wallet
- Buy functionality that calls `buy_item()` on MarketplaceCanister using Plug wallet
- Real-time updates when assets are bought, listed, or delisted
- Visual feedback for successful transactions and error handling with specific error messages
- Display of user's own active listings with management options
- Glassmorphism styling for all marketplace panels and listing cards

### Governance Tab
- "GOVERNANCE" tab with enhanced cyberpunk/glitch UI styling and glassmorphism panels
- Staking interface:
  - Display current staked CBR token balance with proper decimal formatting
  - Input field and "STAKE TOKENS" button to call `stakeTokens()` using Plug wallet
  - Visual confirmation of staking transactions
- Proposal display:
  - List of active proposals with title, description, and voting status
  - Voting interface with "YES" and "NO" buttons using Plug wallet for vote signing
  - Vote weight display based on staked token balance
  - Real-time vote count and percentage displays
- Create proposal interface:
  - Text inputs for proposal title and description
  - "CREATE PROPOSAL" button to submit new proposals using Plug wallet
  - Validation for minimum stake requirements
- Real-time updates of proposal status and voting results
- Display of user's voting history and current stakes

### Map View
- React Leaflet integration showing neon-styled map
- Marker positioned at currently selected land's coordinates
- Enhanced cyberpunk styling with glassmorphism overlay panels

### Visual Design
- **Unified "Soft Cyberpunk Space Noir" theme**: Neon Green (#00ff41) and Cyber Blue (#00d4ff) accents with deep black/dark grey backgrounds
- **Low-resource animated cosmic background**: Nebula and stars with green/blue/purple hues covering entire interface
- **Glassmorphism panels**: Semi-transparent frosted glass effect with subtle neon glow borders and rounded corners
- **Compact top-right header integration**: Minimalist header bar with key metrics and wallet connection
- **Enhanced font and readability**: High-contrast typography with improved legibility across all panels
- **Corrected global text color styling**: All default (non-themed) text changed from black to white or light-cyan while preserving existing accent colors (green, purple, magenta, etc.)
- Orbitron or JetBrains Mono fonts
- Glitch UI details and enhanced neon lighting effects
- Tailwind CSS and Framer Motion for consistent cyberpunk styling with glassmorphism
- Responsive design for desktop and mobile
- All UI text displayed in Russian language
- Perfect visual harmony with R3F dynamic scenes

## Backend Architecture

### AssetCanister (3D Model Hosting with GLB Support)
- **Enhanced memory capacity configuration**: **500 MB memory allocation** for handling large GLB files and multiple asset storage
- Dedicated canister for hosting 3D model assets (.glb, .obj files) for the 45+ modifiers and biome textures
- **Health check endpoint**: `http_request` method that responds to `/health` requests with 200 status code for canister health monitoring
- **Enhanced GLB model support with proper MIME type handling and extended timeout configuration**:
  - **MIME type validation** for "model/gltf-binary" during GLB file uploads
  - **File extension validation** ensuring only `.glb` files are accepted for 3D models
  - **Binary data handling** optimized for GLB file format specifications
  - **Persistent storage** using stable memory for all uploaded GLB models with orthogonal persistence
  - **Stable URL generation** ensuring GLB models remain accessible across canister upgrades
  - **Extended timeout handling**: **120-second (2-minute) timeout** for large GLB file uploads to prevent connection drops during 50MB transfers
  - **Enhanced compute resource allocation**: Sufficient cycles and memory allocation to handle large blob uploads without performance degradation
- Batch upload script with dfx command for uploading all 3D model assets and biome textures
- Stable URL generation for AssetCanister-hosted models ensuring URLs remain consistent post-deployment
- Asset management functions:
  - **Enhanced `uploadAsset(filename: Text, data: Blob)` with GLB validation and extended timeout**:
    - **MIME type verification** for "model/gltf-binary" when filename ends with ".glb"
    - **File size validation** with appropriate limits for 3D model files
    - **Binary data integrity checks** to ensure valid GLB file structure
    - **Persistent storage** with orthogonal persistence guaranteeing data survives canister upgrades
    - **Extended timeout handling**: **120-second timeout** for large file processing
  - **Fixed `uploadLandModel(landTypeName: Text, modelData: Blob)` function with proper Candid interface export and extended timeout support**:
    - **Explicitly marked as `public shared` function** to ensure it appears in the generated Candid `.did` interface
    - **Exact function signature**: `public shared func uploadLandModel(landTypeName : Text, modelData : Blob) : async Text`
    - **Restricted access**: Only callable by Internet Identity principal `whd5e-pbxhk-pp65k-hxqqx-edtrx-5b7xd-itunf-pz5f5-bzjut-dxkhy-4ae`
    - **Strict security check**: `msg.caller == Principal.fromText("whd5e-pbxhk-pp65k-hxqqx-edtrx-5b7xd-itunf-pz5f5-bzjut-dxkhy-4ae")` validation before processing
    - **Enhanced file size validation**: Validates file size is ‚â§ 52,428,800 bytes (50 MB) and returns "File size exceeds 50 MB limit" error if exceeded
    - **Static land type validation**: Accepts only exact matches for the 7 land types: `FOREST_VALLEY`, `ISLAND_ARCHIPELAGO`, `SNOW_PEAK`, `DESERT_DUNE`, `VOLCANIC_CRAG`, `MYTHIC_VOID`, `MYTHIC_AETHER`
    - **Direct filename mapping**: Stores GLB file using `landTypeName` exactly (e.g., `FOREST_VALLEY.glb`)
    - **GLB file validation**: MIME type and format verification for uploaded models
    - **Secure storage**: Persistent storage with stable URL generation
    - **Extended timeout handling**: **120-second (2-minute) timeout** for large GLB file processing to prevent upload failures
    - **Enhanced compute resource management**: Optimized memory allocation and cycle consumption for large blob handling
    - **Error handling**: Returns "Unauthorized" error for non-matching principals or comprehensive error messages for invalid files or oversized uploads
    - **Integration**: Works with frontend AdminPanel component for secure model management
    - **Candid interface export**: Function must be properly exported in the generated `.did` file for frontend actor creation
  - **Emergency admin method `emergencyAdmin()` for temporary admin assignment**:
    - **Temporary admin assignment**: When GovernanceCanister is unavailable, allows caller to become temporary admin
    - **Fallback authorization**: Provides backup access when primary governance system is offline
    - **Security validation**: Includes appropriate security checks and logging for emergency access
    - **Text confirmation return**: Returns clear text confirmation of temporary admin status assignment
    - **Limited scope**: Emergency admin has restricted permissions compared to full governance access
    - **Audit trail**: All emergency admin actions are logged for security audit purposes
  - `batchUploadAssets(assets: [(Text, Blob)])` for bulk asset uploads with extended timeout support
  - `getAssetUrl(filename: Text)` returns stable URL for accessing uploaded assets
  - `listAssets()` returns array of all uploaded asset filenames including GLB models
  - **`listGLBModels()` specialized function** returning only GLB model filenames and URLs
  - **`getCycleBalance()` function** returns current cycle balance of the AssetCanister for monitoring purposes
  - **`getCanisterStatus()` function** returns comprehensive canister health information including memory usage and compute statistics
  - **`testGatewayConnectivity()` function** tests connectivity across all three gateways (`ic0.app`, `boundary.ic0.app`, `icp-api.io`) and returns response times and status codes
  - **`getNetworkHealthReport()` function** provides comprehensive network health assessment including gateway performance metrics and stability recommendations
- **Persistent storage using stable memory** for asset data with orthogonal persistence model
- Authorization system ensuring only GovernanceCanister and authorized admin can manage assets
- Integration with LandCanister for providing model URLs to modification system
- **Public IC network deployment configuration** with stable public URLs in format `https://bd3sg-teaaa-aaaaa-qaaba-cai.raw.ic0.app/[LAND_TYPE].glb`
- Production-ready asset serving with proper CORS headers and content-type handling for GLB files
- **Enhanced performance optimization for large file handling**:
  - **Sufficient cycle allocation** to handle 50MB GLB uploads without running out of compute resources
  - **Memory management optimization** for processing large binary blobs
  - **Connection stability improvements** to prevent timeout failures during extended upload operations
  - **Network request optimization** with proper buffering and streaming for large file transfers
- Biome texture hosting for skybox and environment assets:
  - `forest-valley-skybox.png` for forest valley biome backgrounds
  - `island-archipelago-skybox.png` for island archipelago biome backgrounds
  - `snow-peak-skybox.png` for snow peak biome backgrounds
  - `desert-dune-skybox.png` for desert dune biome backgrounds
  - `volcanic-crag-skybox.png` for volcanic crag biome backgrounds
  - `mythic-void-celestial-sphere.png` for MYTHIC_VOID biome animated backgrounds
  - `mythic-aether-celestial-sphere.png` for MYTHIC_AETHER biome animated backgrounds
- **Critical AssetCanister redeployment and interface regeneration with performance optimizations**:
  - **Complete canister rebuild**: Redeploy AssetCanister with proper `public shared` function declaration for `uploadLandModel` and extended timeout support
  - **Candid interface regeneration**: Generate new `.did` file ensuring `uploadLandModel : (text, blob) -> (text)` is properly exported
  - **Frontend actor binding update**: Update frontend to import regenerated `.did` interface so `assetActor.uploadLandModel` is recognized
  - **Function visibility verification**: Confirm `uploadLandModel` appears in generated Candid interface and is callable from frontend
  - **Principal access control maintenance**: Keep strict access limited to `whd5e-pbxhk-pp65k-hxqqx-edtrx-5b7xd-itunf-pz5f5-bzjut-dxkhy-4ae`
  - **File size validation preservation**: Maintain 50 MB limit enforcement on both backend and frontend
  - **Extended timeout implementation**: Deploy with **120-second timeout** configuration for large file handling
  - **Performance optimization deployment**: Ensure sufficient compute resources and cycle allocation for large blob processing
  - **Public IC network deployment**: Deploy to public Internet Computer network with stable connectivity and enhanced performance
  - **Full reinitialization**: Cleanly rebuild and redeploy Asset Canister (bd3sg-teaaa-aaaaa-qaaba-cai) to ensure Wasm modules, candid interfaces, and references are correctly initialized and compatible
  - **Connection restoration**: Restore canister visibility and Connected status through complete reinitialization
  - **Health endpoint verification**: Ensure `/health` endpoint is accessible and returns 200 status code

### CyberTokenCanister (ICRC-1 Token)
- Implements ICRC-1 fungible token standard
- Token details:
  - Name: CYBER
  - Symbol: CBR
  - Decimals: 8
  - Total Supply: 1,000,000,000 tokens
- Required ICRC-1 methods:
  - **`icrc1_balance_of(account: Account)` returns token balance without access control restrictions for user-visible balance requests**
  - **`icrc1_transfer(args: TransferArgs)` transfers tokens between accounts with proper Principal ID validation and fee handling**
  - `icrc1_metadata()` returns token metadata
  - `icrc1_total_supply()` returns total token supply
- **Enhanced token transfer operations with comprehensive error handling, audit compliance, and detailed logging:**
  - **Proper Principal ID validation for source and destination accounts**
  - **Correct fee calculation and inclusion in transfer amounts to prevent underpayment**
  - **Detailed `Debug.print` statements for all transfer operations: `Debug.print("Token transfer from: " # debug_show(from) # " to: " # debug_show(to) # " amount: " # debug_show(amount))`**
  - **Enhanced `TransferResult` handling ensuring `#Ok` cases properly update balances with logging: `Debug.print("Transfer successful, new balance: " # debug_show(newBalance))`**
  - **Custom error messages for insufficient funds, bad fee calculations, and generic transfer errors with detailed logging**
  - **Transaction error propagation to frontend logs with readable error descriptions**
- **Enhanced privileged `mint(to: Principal, amount: Nat)` function with comprehensive logging:**
  - **Callable only by LandCanister with proper authorization validation**
  - **Detailed logging for mint operations: `Debug.print("Minting " # debug_show(amount) # " tokens to Principal: " # debug_show(to))`**
  - **Success confirmation logging: `Debug.print("Mint successful, new balance: " # debug_show(newBalance))`**
  - **Error handling and logging for failed mint operations**
- **New diagnostic query method `getCanisterTokenBalance(): async Nat`:**
  - **Returns the CBR token balance owned by the CyberTokenCanister itself**
  - **Used for debugging and audit purposes to verify canister's own token holdings**
  - **Accessible for administrative debugging and balance verification**
  - **Includes proper error handling and logging for balance retrieval**
- Persistent storage using OrderedMap for account balances
- Authorization system ensuring only LandCanister can mint new tokens
- GovernanceCanister configured as controller for administrative oversight

### LandCanister (Main Application Logic)
- **Enhanced memory capacity configuration**: **500 MB memory allocation** for handling large datasets and initialization stability
- Extended LandData type containing:
  - principal (Principal)
  - coordinates with lat and lon (Float)
  - biome (Text, restricted to 7 valid values: `FOREST_VALLEY`, `ISLAND_ARCHIPELAGO`, `SNOW_PEAK`, `DESERT_DUNE`, `VOLCANIC_CRAG`, `MYTHIC_VOID`, `MYTHIC_AETHER`)
  - upgradeLevel (Nat, default 0, max 5)
  - lastClaimTime (Time)
  - plotName (Text, user-customizable, max 20 characters)
  - decorationURL (?Text, optional on-chain hosted SVG or 3D asset URL)
  - baseTokenMultiplier (Float, 1.25 for MYTHIC_VOID and MYTHIC_AETHER lands, 1.0 for others)
  - cycleCharge (Nat, current charge units available)
  - chargeCap (Nat, maximum charge units that can be accumulated, set to 1000)
  - lastChargeUpdate (Time, timestamp of last charge calculation)
  - landId (Nat, unique identifier for each land)
- LandToken type containing:
  - token_id (Nat, unique identifier)
  - rarity (Text, "RARE" for standard LandTokens)
- Modifier type containing:
  - mod_id (Nat)
  - rarity_tier (Nat)
  - name (Text)
  - multiplier_value (Float)
  - asset_url (Text)
- Modification type containing:
  - mod_id (Nat)
  - rarity_tier (Nat, 1-4)
  - multiplier_value (Float)
  - model_url (Text, URL to 3D model asset from AssetCanister for visualization)
- EnergyBooster type containing:
  - amount (Nat)
- ConsumableBuff type containing:
  - type (Text)
  - duration (Nat)
- LootCache type containing:
  - cache_id (Nat)
  - tier (Nat, 1-3 for Common/Rare/Legendary)
  - owner (Principal)
  - discovered_at (Time)
  - is_opened (Bool)
- Reference to CyberTokenCanister Principal ID for inter-canister calls
- Reference to ICP Ledger canister Principal ID for ICP payment processing
- Reference to GovernanceCanister Principal ID for administrative access control
- Reference to AssetCanister Principal ID for 3D model URL retrieval
- **Multi-land ownership system with Map<Principal, [LandData]> storage structure**
- **Enhanced biome assignment function with strict validation:**
  - **`getBiomeFromCoordinates(lat: Float, lon: Float) : Text` helper function:**
    - **Deterministically maps coordinates to one of the 7 valid biomes only**
    - **Uses coordinate-based hashing or zone logic to return exclusively: `FOREST_VALLEY`, `ISLAND_ARCHIPELAGO`, `SNOW_PEAK`, `DESERT_DUNE`, `VOLCANIC_CRAG`, `MYTHIC_VOID`, `MYTHIC_AETHER`**
    - **Includes 0.5% random chance for `MYTHIC_VOID` or `MYTHIC_AETHER` assignment**
    - **All other coordinate ranges map to the 5 standard biomes**
    - **No fallback to unauthorized biome values**
    - **Standalone function using only standard Motoko math operators**
- **Private `updateCharge(data: LandData) : LandData` helper function with enhanced safety and fail-fast mechanisms:**
  - **Calculates elapsed time since `data.lastChargeUpdate` with strict bounds checking and overflow prevention**
  - **Uses simplified elapsed time computation to prevent infinite loops or numeric overflow conditions**
  - **Includes `assert` statements to ensure elapsed time calculations are within reasonable bounds (e.g., assert elapsed_seconds < 86400 * 365)**
  - **Increases `data.cycleCharge` by 1 unit per minute elapsed with runtime bounds validation**
  - **Ensures accumulated `cycleCharge` never exceeds `chargeCap` (1000 units maximum) and never goes negative with explicit bounds validation**
  - **Caps `data.cycleCharge` at `data.chargeCap` with explicit bounds validation and `assert` statements**
  - **Updates `data.lastChargeUpdate` to current time with validation**
  - **Returns updated LandData with new charge values or traps with clear error message on failure**
  - **Executes synchronously and terminates without exceptions or uses `Debug.trap("Charge calculation failed")` for fail-fast error handling**
- **Enhanced land minting logic with strict biome validation:**
  - **After generating deterministic coordinates, calls `getBiomeFromCoordinates(lat, lon)`**
  - **Validates returned biome is one of the 7 authorized values before assignment**
  - **Sets baseTokenMultiplier to 1.25 for MYTHIC_VOID and MYTHIC_AETHER lands, 1.0 for others**
  - **Assigns only validated biome values to the `biome` field in LandData**
  - **Ensures biome assignment is deterministic and permanently stored**
  - **Sets chargeCap to 1000 for all new lands**
  - **Includes data migration logic to cleanse any existing lands with unauthorized biome values, remapping them to `FOREST_VALLEY` as default**
- `initializeAccessControl()` method for setting up user access and data on first login with error handling
- **`getLandData()` returns current user's land collection as [LandData], creating first land deterministically if collection is empty, with biome validation ensuring only authorized values, wrapped in comprehensive try-catch with `Debug.trap("Land data retrieval failed")` for fail-fast error handling**
- **`getLandDataQuery()` query function with try-catch error handling, biome validation, and `Debug.trap()` statements for error propagation and fail-fast behavior**
- `getCallerUserProfile()` returns user profile information with error handling
- `getUserModifications()` function returns array of user's modifications sorted by rarity tier (highest first) with AssetCanister URLs
- **`getMyModifications()` function returns array of user's collected modifications for Collection Mastery progress calculation with optimized persistent storage access and fail-fast error handling**
- **`mintLand()` function for creating additional lands:**
  - **Requires valid LandToken from user's inventory**
  - **Consumes one LandToken upon successful land creation**
  - **Generates new deterministic coordinates and biome for additional land**
  - **Assigns unique landId to each new land**
  - **Adds new LandData to user's land collection**
  - **Returns new land information or error if no LandTokens available**
- **Enhanced `claimRewards(landId: Nat)` function with comprehensive error handling, audit compliance, and detailed logging:**
  - **Calls `updateCharge()` to refresh charge units before processing for specified land**
  - **Requires at least 10 units of Cycle Charge to execute**
  - **Enforces 24-hour cooldown (86,400 seconds) since lastClaimTime for specified land**
  - **Deducts 10 units of Cycle Charge when successfully executed**
  - **Calculates reward as 100 * (upgradeLevel + 1) * baseTokenMultiplier tokens for specified land**
  - **Enhanced inter-canister call to CyberTokenCanister's mint function with comprehensive logging:**
    - **Detailed logging before mint call: `Debug.print("Claiming rewards for landId: " # debug_show(landId) # " Principal: " # debug_show(caller) # " Amount: " # debug_show(rewardAmount))`**
    - **Verification that tokens are minted to the caller's Principal ID (not LandCanister): `Debug.print("Minting to caller Principal: " # debug_show(caller))`**
    - **Success confirmation logging: `Debug.print("Mint successful for claim, tokens credited to user: " # debug_show(rewardAmount))`**
    - **Failure logging with specific error details: `Debug.print("Mint failed for claim: " # debug_show(error))`**
    - **Error handling and logging for failed mint operations with specific error messages**
    - **Verification that the correct Principal is used for the minting call (caller) to ensure user's balance updates in the token canister**
  - **Updates lastClaimTime in specified LandData**
  - **Returns remaining cooldown time if not ready or insufficient charge**
  - **Comprehensive error handling with detailed logging for all failure cases**
- `upgradePlot(landId: Nat, cost: Nat)` function:
  - Calls `updateCharge()` to refresh charge units before processing for specified land
  - Verifies user's token balance via inter-canister call
  - Deducts cost through token transfer and increments upgradeLevel (max 5) for specified land
  - Returns status message
- `updatePlotName(landId: Nat, name: Text)` function:
  - Validates name length is ‚â§ 20 characters
  - Updates plotName field for specified land
  - Returns validation result
- `updateDecoration(landId: Nat, url: Text)` function:
  - Validates URL format is well-formed
  - Updates decorationURL field for specified land
  - Returns validation result
- **Enhanced `discoverLootCache(tier: Nat)` function with comprehensive error handling, audit compliance, and detailed logging:**
  - **Accepts desired cache tier (1-3) as input parameter**
  - **Calls `updateCharge()` to refresh charge units before processing**
  - **Enforces tier-specific cycle charge deduction for all tiers with proper validation**
  - **Supports dual payment logic with CBR and ICP payment methods**
  - **Enhanced CBR payment processing with detailed error handling, audit compliance, and comprehensive logging:**
    - **Validates user has sufficient CBR balance before attempting transfer with proper Principal ID verification**
    - **Uses correct Principal IDs for transfer: caller's Principal as source, LootBoxCanister Principal as destination**
    - **Calculates transfer amount correctly accounting for ICRC-1 transfer fees (typically 10,000 units) to prevent underpayment**
    - **Detailed logging for discovery operations: `Debug.print("Discovering cache tier: " # debug_show(tier) # " Principal: " # debug_show(caller) # " CBR Cost: " # debug_show(cbrCost))`**
    - **Implements comprehensive error handling with detailed `Debug.print` statements for debugging transfer failures**
    - **Returns descriptive error messages like "InsufficientFunds", "TransferError", "Unauthorized", or "FeeCalculationError" instead of silent failures**
    - **Uses proper try-catch blocks with `Result<LootCache, Text>` return type for error propagation**
    - **Includes detailed error logging for failure cases: `Debug.print("CBR Transfer Failed: " # debug_show(error))`**
    - **Validates transfer completion before proceeding with cache creation**
  - **Creates new LootCache record only after successful payment verification**
  - **Implements proper rollback mechanisms if any step fails**
  - **Never hangs silently - always returns either success result or descriptive error string**
  - **Enhanced error logging with specific messages for each failure point in the transaction flow**
- Enhanced `processCache(cache_id: Nat)` function:
  - Validates cache exists and belongs to caller
  - Enforces 4-hour delay from discovered_at time or allows charge cost bypass
  - Implements tier-specific drop table logic:
    - Tier 1 (Common Cache): 70% Common Modifiers, 30% Rare Modifiers, CBR tokens, 0.05% LandToken
    - Tier 2 (Rare Cache): includes ~3% chance for ConsumableBuff, ~1% chance for EnergyBooster, CBR tokens, 0.2% LandToken
    - Tier 3 (Legendary Cache): increased drop chances for Buffs, Boosters, CBR tokens, 0.5% LandToken
  - Randomly generates appropriate rewards based on cache tier including CBR token amounts
  - Sets appropriate multiplier_value based on tier
  - Assigns model_url from AssetCanister based on rarity tier for 3D visualization
  - Makes inter-canister call to AssetCanister to retrieve stable model URLs
  - Marks cache as opened (is_opened = true)
  - Persists reward records tied to caller's Principal
  - Returns the generated reward record
- `useConsumableBuff(item_id: Nat)` function:
  - Validates buff exists and belongs to caller
  - Temporarily increases user's token multiplier for 24-hour duration
  - Removes the used buff from user's inventory
  - Updates user's active buff status and expiration time
  - Returns confirmation of buff activation
- `getTopLands(limit: Nat)` function:
  - Returns ranked array of lands sorted by upgradeLevel (highest first)
  - Ties resolved by CBR token balance (descending)
  - Uses secure inter-canister calls to CyberTokenCanister.icrc1_balance_of()
  - Returns top limit entries with principal, plotName, upgradeLevel, token balance, and land count
- **Administrative modifier management with optimized persistent storage access:**
  - **`adminSetAllModifiers(modifier_list: [Modifier])` function:**
    - **Restricted to GovernanceCanister Principal ID only via AccessControl system**
    - **Stores the complete provided modifier_list (45+ entries expected) into persistent storage with optimized serialization**
    - **Uses stable variable or OrderedMap for persistent modifier data storage with quick access patterns**
    - **Enables centralized DAO-controlled modifier configuration management**
    - **Returns confirmation of successful modifier data upload or traps with clear error message**
    - **Includes `assert` statements to ensure modifier data integrity and prevent blocking operations during login**
  - **Authorization validation ensures only GovernanceCanister can invoke administrative functions**
  - **Persistent modifier storage accessible by other functions like `processCache()` with efficient deserialization**
- NFT functionality for marketplace integration:
  - `transferLand(to: Principal, landId: Nat)` function for NFT transfers of specific lands
  - `getLandOwner(landId: Nat)` function to verify ownership of specific lands
  - Authorization checks ensuring only land owners can transfer their specific NFTs
- ICP Ledger integration for production payment handling:
  - Inter-canister call interfaces for ICP transfer operations
  - Balance checking and transaction verification methods
  - Proper error handling for ICP payment failures
  - Secure validation of ICP payment completion before proceeding with cache creation
- **`getCycleBalance()` function** returns current cycle balance of the LandCanister for monitoring purposes
- **`getCanisterStatus()` function** returns comprehensive canister health information including memory usage, compute statistics, and deployment hash
- **`testGatewayConnectivity()` function** tests connectivity across all three gateways (`ic0.app`, `boundary.ic0.app`, `icp-api.io`) and returns response times and status codes
- **`getNetworkHealthReport()` function** provides comprehensive network health assessment including gateway performance metrics and stability recommendations
- Orthogonally persistent storage using OrderedMap collections:
  - Principal to [LandData] mapping for multi-land ownership
  - Principal to LootCache array mapping
  - Principal to Modification array mapping
  - Principal to EnergyBooster array mapping
  - Principal to ConsumableBuff array mapping
  - Principal to [LandToken] mapping for LandToken inventory
  - Modifier data storage for administrative configuration
- Land generation based on hashed principal for deterministic results
- Safe initialization for new users without existing role or land data
- Cycle Charge system persists across canister upgrades using Motoko's orthogonal persistence model
- **All login-related public query and update functions wrapped in comprehensive try-catch blocks with `Debug.trap()` statements for fail-fast error handling**
- **Biome integrity enforcement with validation functions that reject any unauthorized biome values and cleanse existing data**
- **Enhanced error handling for all token transaction functions to prevent silent failures and provide descriptive error messages with detailed logging**
- **Comprehensive audit compliance for token transfer operations with proper Principal ID validation, fee handling, and error propagation**
- GovernanceCanister configured as controller for administrative oversight
- **Full reinitialization**: Cleanly rebuild and redeploy Land Canister (br5f7-7uaaa-aaaaa-qaaca-cai) to ensure Wasm modules, candid interfaces, and references are correctly initialized and compatible
- **Connection restoration**: Restore canister visibility and Connected status through complete reinitialization

### LootBoxCanister (Loot Cache Management)
- Manages loot cache system with secure CBR token accumulation and withdrawal
- Accumulates CBR tokens from loot cache purchases and operations
- `withdraw_cbr(amount: Nat)` function:
  - Restricted to canister controller (owner Principal ID) only
  - Implements assertion check to validate caller is the authorized controller
  - Transfers specified CBR token amount from canister to controller's wallet
  - Makes secure inter-canister call to CyberTokenCanister for token transfer
  - Returns confirmation of successful withdrawal or error if insufficient balance
  - Includes proper error handling for failed transfers
- Persistent storage for accumulated CBR token balance
- Authorization system ensuring only controller can withdraw accumulated tokens
- Integration with CyberTokenCanister for secure token transfers
- GovernanceCanister configured as controller for administrative oversight

### MarketplaceCanister (P2P NFT and Modifier Trading)
- Facilitates secure P2P trading of both Land NFTs and Modifiers for CBR tokens with atomic swap logic
- ItemType enum containing:
  - Land (for Land NFT listings)
  - Modifier (for Modifier listings)
- Listing data structure containing:
  - listingId (Nat, unique identifier)
  - itemId (Nat, specific asset identifier - landId for lands, modId for modifiers)
  - itemType (ItemType, Land or Modifier)
  - seller (Principal)
  - price (Nat, in CBR tokens)
  - isActive (Bool, listing status)
- `list_item(item_id: Nat, item_type: ItemType, price: Nat)` function:
  - Verifies caller owns the specified asset (Land or Modifier) via LandCanister
  - Transfers specific asset from seller to marketplace principal for escrow
  - Creates active listing with unique ID, asset type, and seller information
  - Returns listing ID for tracking
- **Enhanced `buy_item(listing_id: Nat)` function with comprehensive error handling, audit compliance, and detailed logging:**
  - **Executes atomic swap transferring specific asset to buyer and CBR payment to seller**
  - **Enhanced CBR transfer validation with proper Principal ID handling, audit compliance, and comprehensive logging:**
    - **Uses correct Principal IDs: buyer's Principal as source, seller's Principal as destination**
    - **Calculates transfer amount correctly accounting for ICRC-1 transfer fees to prevent underpayment**
    - **Validates buyer has sufficient CBR balance including fees before attempting transfer**
    - **Detailed logging for purchase operations: `Debug.print("Marketplace purchase - Buyer: " # debug_show(buyer) # " Seller: " # debug_show(seller) # " Amount: " # debug_show(amount))`**
    - **Implements comprehensive error handling with detailed `Debug.print` statements for transaction debugging**
    - **Returns descriptive error messages like "InsufficientFunds", "TransferError", "ItemUnavailable", or "FeeCalculationError"**
    - **Uses proper try-catch blocks with `Result<Text, Text>` return type for error propagation**
    - **Includes detailed error logging: `Debug.print("Marketplace Purchase Failed: " # debug_show(error))`**
  - **Implements proper rollback handling if any transfer step fails**
  - **Never hangs silently - always provides clear transaction outcome**
  - **Handles both Land NFT and Modifier transfers based on listing item type**
  - **Preserves asset consistency throughout the transaction**
  - **Marks listing as inactive after successful purchase**
  - **Enhanced error logging with specific messages for each failure point in the purchase flow**
- `cancelListing(listingId: Nat)` function:
  - Allows seller to delist their specific asset and return it to their ownership
  - Verifies caller is the original seller
  - Transfers specific asset back from marketplace to seller based on item type
  - Marks listing as inactive
- `getActiveListings()` query function:
  - Returns array of all active listings with asset details
  - Includes seller information, price, asset type, and asset metadata
  - Provides filtering support for frontend display
- `getUserListings(user: Principal)` query function:
  - Returns all listings (active and inactive) for a specific user
  - Includes both Land and Modifier listings
- Persistent storage for active listings and transaction history
- Authorization system ensuring only valid asset owners can list their specific NFTs or Modifiers
- Inter-canister communication with LandCanister for asset operations and CyberTokenCanister for payments
- GovernanceCanister configured as controller for administrative oversight

### GovernanceCanister (Decentralized Governance)
- Manages decentralized project governance with CBR token-weighted voting
- Staker data structure containing:
  - principal (Principal)
  - stakedAmount (Nat, locked CBR tokens)
  - stakingTime (Time, when tokens were staked)
- Proposal data structure containing:
  - proposalId (Nat, unique identifier)
  - title (Text)
  - description (Text)
  - creator (Principal)
  - creationTime (Time)
  - votingDeadline (Time)
  - yesVotes (Nat, weighted vote count)
  - noVotes (Nat, weighted vote count)
  - isActive (Bool, proposal status)
- `stakeTokens(amount: Nat)` function:
  - Locks user's CBR tokens for governance participation
  - Makes inter-canister call to CyberTokenCanister for token transfer to governance canister
  - Updates staker balance and voting power
  - Returns confirmation of successful staking
- `createProposal(title: Text, description: Text)` function:
  - Validates caller has minimum staked tokens for proposal creation
  - Creates new proposal with unique ID and 7-day voting period
  - Stores proposal with creator information and timestamps
  - Returns proposal ID for tracking
- `vote(proposalId: Nat, choice: Bool)` function:
  - Validates proposal exists and is still active (within voting deadline)
  - Prevents double voting by the same principal
  - Weights votes by caller's staked CBR token balance
  - Updates proposal vote counts (yesVotes or noVotes)
  - Returns confirmation of vote recording
- `getActiveProposals()` query function:
  - Returns array of all active proposals with voting statistics
  - Includes vote counts, percentages, and time remaining
- `getProposalDetails(proposalId: Nat)` query function:
  - Returns detailed information for a specific proposal
  - Includes voting history and current status
- `getStakerInfo(user: Principal)` query function:
  - Returns staking information for a specific user
  - Includes staked amount and voting power
- `closeProposal(proposalId: Nat)` function:
  - Administrative function to close expired proposals
  - Calculates final voting results and marks proposal as inactive
- Persistent storage for staker balances, proposals, and voting records
- Proposal lifecycle management with time-based voting periods
- Inter-canister communication with CyberTokenCanister for token staking operations
- Administrative control over all other canisters as their designated controller

## AssetCanister Deployment Guide

### Complete AssetCanister Source Code
The AssetCanister requires the following complete Motoko implementation with proper CORS headers and health endpoint:

